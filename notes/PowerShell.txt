get powershell version:
$PSVersionTable

update help on commands:
update-help -UICulture en-US

get type of object:
<object>.GetType()

get an object methods and properties:
<object> | Get-Member

access recycle bin of current filesystem drive:
cd '\$RECYCLE.BIN\'

open recycle bin in explorer:
start shell:RecycleBinFolder

the drives remember the state in which you left them:
- "<drive>:" refers to the last container the drive visited
- "<drive>:/" refers to the drive's root container

you only need to type enough of the parameter name to uniquely identify it
(-f => -force if nothing else starts with an f)

PS has access to the same .exe commands as the command prompt
(just add ".exe" to specify the command prompt executable)

=> find the path of an executable in the "path"(.exe file):
where.exe <exe_name>

make a SymbolicLink:
New-Item -ItemType SymbolicLink -Path '<link_path>' -Target '<original_item_path>'
New-Item -ItemType SymbolicLink -Path 'C:\Users\Arthur\Desktop\wt_asadmin.exe.lnk' -Target 'C:\Program Files\WindowsApps\Microsoft.WindowsTerminal_1.17.11461.0_x64__8wekyb3d8bbwe\wt.exe'

accessing elements of a list that do not exist is always possible (returns $null):
$empty_list = @(); $empty_list[10]

time an expression:
Measure-Command { Get-WinEvent "windows powershell" }

test powershell load time:
Measure-Command{ powershell.exe -Command "exit" }
Measure-Command{ pwsh.exe -Command "exit" }


- processes and jobs:
start a powershell terminal through a script with a hidden window:
$jupyter_server_process = Start-Process -FilePath .\jupyter_server.ps1 -PassThru
$jupyter_server_process = Start-Process -FilePath .\jupyter_server.ps1 -WindowStyle "Hidden" -PassThru
kill the terminal and its childs:
Stop-ProcessTree $jupyter_server_process.Id

Start-Process -FilePath "pwsh.exe" -ArgumentList "-c","Write-Output","sleeping;","Start-Sleep","10;"
Start-Process -FilePath "powershell.exe" -ArgumentList "-c","Write-Output","sleeping;","Start-Sleep","10;"

$args_list = "Write-Output","sleeping;","Start-Sleep","10;"
Start-Process powershell.exe -ArgumentList (@("-c") + $args_list)
$command_str = "Write-Output 'sleeping...'; Start-Sleep 10;"
Start-Process powershell.exe -ArgumentList (@("-c") + $command_str.Split(" "))
Start-Process powershell.exe -ArgumentList ("-c " + $command_str)

$server_dir = "$(Split-Path $custom_profile_dir -Parent)\jupyter_server"
$command_str = "& `"$server_dir\jupyter_server.ps1`""
Start-Process powershell.exe -ArgumentList ("-c " + $command_str)


- show hastables as nice tables (ft = Format-Table) / lists of "key: value" (fl = Format-List):
# only keys chosen by PS
$my_hashtable | ft
# all keys
$my_hashtable | ft *
(fl always writes all keys)
# only some keys
$my_hashtable | ft <key1>,<key2>,...
$my_hashtable | fl <key1>,<key2>,...


- try - catch - finally:
"try" runs everything until a terminating error ("throw") is thrown.
After that, it stops running the "try" block and looks for a corresponding "catch" block.
After that, it runs the "finally" block.
All blocks must be next to each other.


- Write-Output - Write-Host - Write-Verbose - Write-Information:
Write-Host $null != Write-Output $null
Write-Host @(1,2,3) != Write-Output @(1,2,3)
- Write-Output writes the specified objects to the pipeline. If Write-Output is the last command in the pipeline, the objects are displayed in the console.
=> Write-Output returns its input as output of the function that calls it
- Write-Host writes customized output to a host.
- Write-Verbose writes text to the verbose message stream. (-Verbose to show)
=> Write-Verbose -Message "lol" -Verbose
- Write-Verbose writes text to the information message stream. (-Information "Continue", or $InformationPreference = 'Continue')
Write-Information -MessageData "Processes starting with 'P'" -InformationAction "Continue"


- cmdlet: https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_functions_advanced?view=powershell-7.3
cmdlet inherits from "functions", but isn't a function => has more functionalities
- to turn a function into a cmdlet:
function Do-Smth {[CmdletBinding()] param(...) ...}
- CmdletBinding: transforms a standard function into a full-fledged cmdlet
[CmdletBinding(
    ConfirmImpact=<String>,             # 'None', 'Low', 'Medium', 'High' (default 'Medium')
    DefaultParameterSetName=<String>,   # smth about parameter set, not rly useful
    HelpURI=<URI>,                      # internet address of the online version of the help topic that describes the function
    SupportsPaging=<Boolean>,           # adds the First, Skip, and IncludeTotalCount parameters to the function. Useful when a ton of data is being processed.
    SupportsShouldProcess=<Boolean>,    # adds -Confirm and -WhatIf switches to the function. The cmdlet will request confirmation if
                                        # $ConfirmPreference is equal to or less than the value of ConfirmImpact. (default $False)
    PositionalBinding=<Boolean>         # determines whether parameters in the function are positional by default (default $True)
                                        # => set to $False to disable positional parameter binding.
)]
- parameter attributes: gives more control on cmdlet arguments
Parameter(Argument=value)
-> Mandatory argument (optional parameter when unspecified): Parameter(Mandatory)
    -> HelpMessage argument (displayed when command is used with missing mandatory arguments, type "!?" to see during prompt): Parameter(Mandatory, HelpMessage="help message content")
-> Positional argument (overrides PositionalBinding of CmdletBinding for this parameter) (can still be named): Parameter(Position=0)
-> ValueFromPipeline argument (accepts entire objects from pipeline): Parameter(ValueFromPipeline)
-> ValueFromPipelineByPropertyName argument (accepts input from a property of a pipeline object, the object property must have the same name or alias): Parameter(ValueFromPipelineByPropertyName)
-> ValueFromRemainingArguments argument (): Parameter(ValueFromRemainingArguments)
- Alias attribute: [Alias("...")]
- SupportsWildcards attribute: [SupportsWildcards()]
- ValidatePattern validation attribute (compares string to the regex): [ValidatePattern("[0-9]{4}")]
- ValidateDrive validation attribute (raises error when the value is outside the drives given): [ValidateDrive("C", "D", "Variable", "Function")]


- pipelines:
X = Foo(Bar(Hello("World"))) not possible/practical => X = Hello "World" | Bar | Foo


- jobs:
background commands on the same process, on a different thread.
- start a job:
$myjob = Start-Job -ScriptBlock {jupyter lab}
jupyter lab &
- get all jobs:
Get-Job
Get-Job -State "Running"
- getting a job result:
Receive-Job -Job $myjob -keep
Receive-Job 3 -keep
- waiting for a job result with a timeout:
Wait-Job -ID 10 -Timeout 120
- force stop a job:
Stop-Job -Id 9
Stop-Job $myjob
- remove a job from the list: (fails if the job is still running)
Remove-Job $myjob
Remove-Job *
Get-Job | where {$_.State -ne "Running"} | Remove-Job


keyboard shortcuts:
- ctrl + alt + shift + ,
get the list of all keyboard shortcuts
- ctrl + L
clear terminal
- ctrl + space
tab completion
- ctrl + A
copy all current command
- ctrl + R (ctrl + S)
previous (next) command search
- shift + enter
new line, new execution
- alt + .
last used argument


windows terminal:
open a new tab in current window:
wt -w 0 nt
with custom profile:
wt -w 0 nt -p


resources:
cheat sheet console experience: https://devblogs.microsoft.com/powershell-community/cheat-sheet-console-experience/
cheat sheet punctuation: https://www.red-gate.com/simple-talk/wp-content/uploads/2015/09/PSPunctuationWallChart_1_0_4.pdf
automatic variables: https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables?view=powershell-7.3
advanced functions: https://devblogs.microsoft.com/scripting/introduction-to-advanced-powershell-functions/


to test:
- test try - catch - finally
- test diff between Write-Output - Write-Host - Write-Verbose
- test ForEach-Object (%)
- test Where-Object (?)
- test $MyInvocation
- check preference variables https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_preference_variables?view=powershell-7.3
